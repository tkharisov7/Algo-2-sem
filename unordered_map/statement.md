# H. Unordered Map

В этой задаче Вам предлагается реализовать упрощенный аналог одного из популярных контейнеров STL - unordered_map’а.
Вам может пригодиться List, написанный ранее. Кроме того, в вашем контейнере нужно будет правильно поддержать нужные виды итераторов и move-семантику.

Напишите шаблонный класс UnorderedMap<Key, Value, Hash, Equal, Alloc> - упрощенный аналог std::unordered_map.
Здесь Key - тип ключа, Value - тип значения, Hash - используемая хеш-функция (по умолчанию std::hash<Key>, реализовывать hash не надо), Equal
используемый сравниватель (по умолчанию - std::equal_to<Key>), Alloc - используемый аллокатор (по умолчанию - std::allocator<std::pair<const Key, Value»).
Типы Key и Value не обязаны иметь конструкторы по умолчанию, копирующий конструктор и копирующий оператор присваивания. Для создания UnorderedMap с
ними должно быть достаточно, чтобы они имели лишь move-конструктор и move-оператор присваивания. Внутри UnorderedMap публично определим тип NodeType
как std::pair<const Key, Value>. (В std::unordered_map аналогичный тип называется value_type.) 

Должна быть реализована следующая функциональность:
- Конструкторы (в т.ч. копирования и перемещения), деструктор, копирующий и перемещающий операторы присваивания.
- Методы [] и at(key), работающие в среднем за O(1). Метод [] определен только для неконстантных объектов, он создает Value по умолчанию, если по данному
ключу ничего не было. Метод at(key) в таком случае кидает исключение.
- Метод size(), за O(1) возвращающий текущее количество элементов в контейнере.
- Внутренние типы Iterator и ConstIterator, удовлетворяющие требованиям ForwardIterator. Разыменование константного итератора не должно позволять поменять
объект под ним.
- Методы begin(), end(), cbegin(), cend(). Данные методы должны быть реализованы так, чтобы код for (auto it = m.begin(); it != m.end(); ++it); позволял
пройтись по всем лежащим в контейнере элементам за линейное время от количества этих элементов. Инкрементация любого итератора должна происходить за
гарантированное O(1).
- Метод insert, принимающий ссылку на NodeType и возвращающий pair<Iterator, bool>, где bool означает “произошла ли вставка”, а Iterator указывает на
элемент с данным ключом в контейнере (либо уже лежавший там, либо только что вставленный). Метод insert должен эффективно обрабатывать как lvalue, так
и rvalue: не копировать переданную ему NodeType, если она была rvalue! Вставка элемента должна работать за O(1) в среднем.
- Метод insert от пары InputIterator’ов на NodeType, делающий вставку всего данного диапазона в контейнер.
- Метод emplace(Args&&... args), который самостоятельно конструирует NodeType от переданных аргументов (без их копирования, если это возможно) и, не
копируя, вставляет полученный объект NodeType в контейнер, если это возможно. Возвращаемый тип - такой же, как у insert от NodeType. Конструировать
NodeType нужно с помощью правильного аллокатора (то есть Alloc, если он был указан, а точнее, через allocator_traits от него)!
- Метод erase от итератора, а также от пары итераторов (удаляющие один элемент и диапазон элементов соответственно). Итераторы на элементы, которые не
были удалены, должны не инвалидироваться после вызова erase. Удаление одного элемента должно работать за O(1) в среднем.
- Метод find по ключу, возвращающий итератор на найденный элемент или end(), если элемент не был найден. Поиск должен работать в среднем за O(1).
- Методы reserve, max_size, load_factor и max_load_factor, аналогичные методам STL, позволяющие управлять размером хеш-таблицы.
